/**
 * Parametric RAM Memory
 * @author skeleton by António Manuel Adrego da Rocha
 * 
 * @author Nome e NMec do aluno 1
 * @author Nome e NMec do aluno 2
 * 
 * @version data
 */

public class Memory<T extends Comparable<T>>
{ 
	private T[] mem; // memory elements storage
	private int nelem; // number of elements stored actually in the memory

	/**
	* The constructor creates an empty memory with the given size.
	* @param pSize the size of the memory.
	* @throws NegativeArraySizeException if size is negative.
	*/
	@SuppressWarnings ("unchecked") // eliminate the warning generated by the cast
	public Memory (int pSize) throws NegativeArraySizeException
	{
		if (pSize < 1) throw new NegativeArraySizeException ("Wrong size");
		mem = (T[]) new Comparable[pSize];
		nelem = 0; // empty memory
	}

	/**
	* The method returns the size of the memory.
	* @return the size of the memory.
	*/
	public int getSize ()
	{
		return mem.length;
	}

	/**
	* The method returns the number of elements (nelem) stored in the memory.
	* @return the number of elements of the memory.
	*/ 
	public int getNElem ()
	{
		return nelem;
	}

	/**
	* The method returns the element in the given position of the memory.
	* @param pPos the position, an integer between {@code 0} and {@code nelem-1}.
	* @return the element in the given position of the memory.
	* @throws IndexOutOfMemoryException if the given position is invalid.
	*/ 
	public T getElement (int pPos) throws IndexOutOfMemoryException
	{
		if (pPos < 0 || pPos >= nelem)
			throw new IndexOutOfMemoryException ("Position out of the used part of the memory");
		return mem[pPos];
	}

	/**
	* The method changes the element in the given position of the memory.
	* @param pPos the position, an integer between {@code 0} and {@code nelem-1}.
	* @param pObject the element to store in the memory.
	* @throws NullPointerException if the element is invalid.
	* @throws IndexOutOfMemoryException if the given position is invalid.
	*/ 
	public void setElement (int pPos, T pObject) throws NullPointerException, IndexOutOfMemoryException
	{
		if (pObject == null) throw new NullPointerException ("Null element");
		if (pPos < 0 || pPos >= nelem)
			throw new IndexOutOfMemoryException ("Position out of the used part of the memory");
		mem[pPos] = pObject;
	}

	/**
	* The method checks if the memory is empty (0 elements stored).
	* @return  {@code true} if memory is empty, otherwise {@code false}.
	*/
	public boolean isEmpty ()
	{
		return nelem == 0;
	}

	/**
	* The method checks if the memory is full (total elements stored).
	* @return  {@code true} if memory is full, otherwise {@code false}.
	*/
	public boolean isFull ()
	{
		return nelem == mem.length;
	}

	/**
	* The method inserts a new element in the end of the memory if it is not full
	* and increases the number of stored elements.
	* @param pObject the element to store in the memory.
	* @throws NullPointerException if the element is invalid.
	* @throws MemoryFullException if the memory is full.
	*/
	public void insert (T pObject) throws NullPointerException, MemoryFullException
	{
		if (pObject == null) throw new NullPointerException ("Null element");
		if (isFull ()) throw new MemoryFullException ("Full memory");

		mem[nelem++] = pObject;
	}

	/**
	* The method inserts a new element in the given position of the memory if it is not full,
	* it shifts down the following elements and increases the number of stored elements.
	* @param pObject the element to store in the memory.
	* @param pos the position, an integer between {@code 0} and {@code nelem-1}.
	* @throws NullPointerException if the element is invalid.
	* @throws MemoryFullException if the memory is full.
	* @throws IndexOutOfBoundsException if the position is invalid.
	*/
	public void insertPos (T pObject, int pos) throws NullPointerException, MemoryFullException, IndexOutOfBoundsException
	{
		// implement the method
		if (pObject == null) throw new NullPointerException ("Null element");
		if (isFull ()) throw new MemoryFullException ("Full memory");
		if (pos > mem.length-1 || pos < 0) throw new IndexOutOfBoundsException("Index out of bounds");


		T preValue = pObject;
		for(int i = pos; i<mem.length;i++){
			T tmp = preValue;
			preValue = mem[i];
			mem[i] = tmp;
		}
		nelem++;
		

	}

	/**
	* The method removes and returns the last element of the memory if it is not empty
	* and decreases the number of stored elements.
	* @return the last element of the memory.
	* @throws MemoryEmptyException if the memory is empty.
	*/
	public T delete () throws MemoryEmptyException
	{
		if (isEmpty ()) throw new MemoryEmptyException ("Empty memory");
		
		T object = mem[--nelem];
		mem[nelem] = null;
		return object;
	}

	/**
	* The method removes and returns the element in the given position of the memory if it is not empty,
	* it shifts up the following elements and decreases the number of stored elements.
	* @param pos the position, an integer i between {@code 0} and {@code nelem-1}.
	* @return the element in the given position of the memory.
	* @throws MemoryEmptyException if the memory is empty.
	* @throws IndexOutOfBoundsException if the position is invalid.
	*/
	public T deletePos (int pos) throws MemoryEmptyException, IndexOutOfBoundsException
	{
		// implement the method
		if (isEmpty ()) throw new MemoryEmptyException ("Empty memory");
		if (pos > mem.length-1 || pos < 0) throw new IndexOutOfBoundsException("Index out of bounds");

		T desiredElement = mem[pos];

		T[] memTemp = (T[]) new Comparable[mem.length-1];

		for(int i = 0, j=0;i<mem.length;i++){
			if(i != pos){
				memTemp[j++] = mem[i]; 
			}
		}
			
		T[] finalMem = (T[]) new Comparable[mem.length];

		for(int k = 0; k<memTemp.length;k++){
			finalMem[k] = memTemp[k];
		}

		mem = finalMem;
		nelem--;

		return desiredElement;
		
	}

	/**
	* The method searchs and returns the position of the given element of the memory if it is not empty.
	* @param pObject the element to be searched in the memory.
	* @return the index of the element if it is stored in the memory, otherwise {@code -1}.
	* @throws NullPointerException if the element is invalid.
	* @throws MemoryEmptyException if the memory is empty.
	*/
	public int search (T pObject) throws NullPointerException, MemoryEmptyException
	{
		if (pObject == null) throw new NullPointerException ("Null element");
		if (isEmpty ()) throw new MemoryEmptyException ("Empty memory");
		
		for (int i = 0; i < nelem; i++)
			if (mem[i].equals (pObject)) return i;
		return -1;
	}

	/**
	* The method returns the bigger element in the memory.
	* @return the bigger element in the memory.
	* @throws MemoryEmptyException if the memory is empty.
	*/ 
	public T biggerElement () throws MemoryEmptyException
	{
		// implement the method
		if (isEmpty ()) throw new MemoryEmptyException ("Empty memory");

		T max = mem[0];
        
        for (int i = 1; i < mem.length; i++){
			if(mem[i] == null){ //continua o ciclo for caso o elemento da memória seja nulo
				continue;
			}

        	if(mem[i].compareTo(max) > 0 ){
                max = mem[i];
			}
		}
		return max;
	}

	/**
	* The method returns the smaller element in the memory.
	* @return the smaller element in the memory.
	* @throws MemoryEmptyException if the memory is empty.
	*/ 
	public T smallerElement () throws MemoryEmptyException
	{
		// implement the method
		
		if (isEmpty ()) throw new MemoryEmptyException ("Empty memory");

		T min = mem[0];
        
        for (int i = 0; i < mem.length; i++){
			if(mem[i] == null){ //continua o ciclo for caso o elemento da memória seja nulo
				continue;
			}

        	else if(mem[i].compareTo(min) < 0 ){
                min = mem[i];
			}
		}
		return min;
		
	}

	/**
	* The method returns a full/shallow copy of the memory.
	* @return the copy constructor.
	*/
	public Memory<T> copy () // shallow copy of the elements
	{
		// implement the method
		Memory<T> memory = new Memory<>(mem.length);
		try
		{
			
			for(int i = 0;i<mem.length;i++){
				if(mem[i] == null){
					continue;
				}
				memory.insertPos(mem[i], i);
			}
			
		}
		catch(MemoryFullException e)
		{

		}
		return memory;
		
	}

	/**
	* The method removes all elements in the memory.
	* @throws MemoryEmptyException if the memory is empty.
	*/
	public void clear () throws MemoryEmptyException
	{
		// implement the method
		if (isEmpty ()) throw new MemoryEmptyException ("Empty memory");
		T[] newMem = (T[]) new Comparable[mem.length]; //criar novo array com o tamanho original e mudar a referência

		nelem = 0;
		mem = newMem;
		
	}

	/**
	* The method creates a string representing the contents of the memory. 
	* preceded by a message and its size.
	* @return the string representing the memory elements.
	*/
	public String toString ()
	{
		if (isEmpty ()) return "Empty Memory";
		String str = "Memory size " + mem.length + " with " + nelem + " elements\n";
		for (int i = 0; i < nelem; i++) str += mem[i].toString () + " ";
		return str;
	}

	/**
	* The method checks if two memories have the same capacity, size and elements.
	* Despite the elements can be in diferent places of the memories.
	* @param obj the object to be compared with that must be of memory kind.
	* @return  {@code true} if memories are the same or equal, otherwise {@code false}.
	*/
	@SuppressWarnings ("unchecked")
	public boolean equals (Object obj)
	{
		if (this == obj) return true;
		
		Memory<T> mem = (Memory<T>) obj;

		if (this.getSize() != mem.getSize()) return false;
		if (this.getNElem() != mem.getNElem()) return false;
		
		int thisNElem = this.getNElem();
		int memNElem = mem.getNElem();
		for (int i = 0; i < thisNElem; i++)
		{
			boolean found = false;

			for (int j = 0; j < memNElem; j++)	
				try
				{
					if (this.mem[i].equals (mem.getElement (j))) { found = true; break; }
				}
				catch (IndexOutOfMemoryException e) {  }

			if (!found) return false;
		}
		return true;
	}
}
